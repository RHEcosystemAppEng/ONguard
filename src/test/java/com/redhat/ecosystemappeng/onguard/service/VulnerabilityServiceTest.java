/*
 * Copyright 2024 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.redhat.ecosystemappeng.onguard.service;

import static com.github.tomakehurst.wiremock.client.WireMock.equalTo;
import static com.github.tomakehurst.wiremock.client.WireMock.get;
import static com.github.tomakehurst.wiremock.client.WireMock.getRequestedFor;
import static com.github.tomakehurst.wiremock.client.WireMock.ok;
import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;
import static com.github.tomakehurst.wiremock.client.WireMock.serviceUnavailable;
import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;
import static com.github.tomakehurst.wiremock.client.WireMock.urlPathTemplate;
import static com.redhat.ecosystemappeng.onguard.test.WireMockExtensions.OSV_QUERY_API_PATH;
import static com.redhat.ecosystemappeng.onguard.test.WireMockExtensions.OSV_VULN_API_PATH;
import static com.redhat.ecosystemappeng.onguard.test.WireMockExtensions.PURL_WITH_ERROR;
import static com.redhat.ecosystemappeng.onguard.test.WireMockExtensions.PURL_WITH_VULNS;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyList;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.Collections;
import java.util.List;
import java.util.Map;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;

import com.github.tomakehurst.wiremock.WireMockServer;
import com.redhat.ecosystemappeng.onguard.model.Vulnerability;
import com.redhat.ecosystemappeng.onguard.model.VulnerabilityAlias;
import com.redhat.ecosystemappeng.onguard.repository.VulnerabilityRepository;
import com.redhat.ecosystemappeng.onguard.test.InjectWireMock;
import com.redhat.ecosystemappeng.onguard.test.WireMockExtensions;

import io.quarkus.test.InjectMock;
import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.junit.QuarkusTest;
import io.restassured.RestAssured;
import io.smallrye.mutiny.Uni;
import io.smallrye.mutiny.helpers.test.AssertSubscriber;
import io.smallrye.mutiny.helpers.test.UniAssertSubscriber;
import jakarta.inject.Inject;
import jakarta.ws.rs.core.MediaType;

@QuarkusTest
@QuarkusTestResource(WireMockExtensions.class)
public class VulnerabilityServiceTest {

  @InjectWireMock
  WireMockServer server;

  @InjectMock
  VulnerabilityRepository repository;

  static {
    RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();
  }

  @AfterEach
  public void reset() {
    server.resetRequests();
  }

  @Inject
  VulnerabilityService vulnerabilityService;

  @Test
  void testFindByPurls_Empty() {
    var result = vulnerabilityService.findByPurls(null, false).subscribe().withSubscriber(UniAssertSubscriber.create())
        .awaitItem().assertCompleted().getItem();
    assertTrue(result.isEmpty());

    result = vulnerabilityService.findByPurls(Collections.emptyList(), false).subscribe()
        .withSubscriber(UniAssertSubscriber.create()).awaitItem().assertCompleted().getItem();
    assertTrue(result.isEmpty());

    server.verify(0, postRequestedFor(urlEqualTo(OSV_QUERY_API_PATH)));
  }

  @Test
  void testFindByPurls_NoVulns() {
    var purl = "pkg:maven/org.mvnpm.at.vaadin/select@24.0.5?type=jar";
    var purls = List.of(purl);
    var results = vulnerabilityService.findByPurls(purls, false).subscribe()
        .withSubscriber(UniAssertSubscriber.create()).awaitItem().assertCompleted().getItem();

    assertFalse(results.isEmpty());
    assertEquals(purls.size(), results.size());
    var result = results.get(purl);
    assertNotNull(result);
    assertTrue(result.isEmpty());

    server.verify(1, postRequestedFor(urlEqualTo(OSV_QUERY_API_PATH)));
  }

  @Test
  void testFindByPurls_Success() {
    var purls = List.of(PURL_WITH_VULNS);
    var alias = "GHSA-hr8g-6v94-x4m9";
    var vulnerability = new Vulnerability("cve-001", null, null, null, null, null, null);
    when(repository.listByAliases(anyList()))
        .thenReturn(Uni.createFrom().item(List.of(new VulnerabilityAlias(alias, vulnerability))));

    var results = vulnerabilityService.findByPurls(purls, false).subscribe()
        .withSubscriber(UniAssertSubscriber.create()).awaitItem().assertCompleted().getItem();

    assertFalse(results.isEmpty());
    assertEquals(purls.size(), results.size());
    var result = results.get(PURL_WITH_VULNS);
    assertNotNull(result);
    assertEquals(1, result.size());
    var found = result.get(0);
    assertEquals(vulnerability, found);

    server.verify(1, postRequestedFor(urlEqualTo(OSV_QUERY_API_PATH)));
  }

  @Test
  void testFindByPurls_Error() throws InterruptedException {
    var purls = List.of(PURL_WITH_ERROR);

    vulnerabilityService.findByPurls(purls, false)
        .subscribe()
        .withSubscriber(UniAssertSubscriber.create())
        .awaitItem()
        .assertItem(Map.of(PURL_WITH_ERROR, Collections.emptyList()));

    server.verify(1, postRequestedFor(urlEqualTo(OSV_QUERY_API_PATH)));
    server.resetRequests();

    Thread.sleep(1500L);

    server.verify(1, postRequestedFor(urlEqualTo(OSV_QUERY_API_PATH)));
  }

  @Test
  void testGet_OsvRecoverAfteRetry() throws InterruptedException {

    var cveId = "CVE-2023-36095";

    when(repository.listByAliases(anyList()))
        .thenReturn(Uni.createFrom().item(List.of(new VulnerabilityAlias(cveId, null))));
    when(repository.save(any(Vulnerability.class))).thenReturn(Uni.createFrom().voidItem());
    when(repository.setAliases(anyList(), anyString())).thenReturn(Uni.createFrom().voidItem());
    when(repository.get(eq(cveId))).thenReturn(Uni.createFrom().nullItem());

    server.stubFor(get(urlPathTemplate(OSV_VULN_API_PATH))
        .withPathParam("id", equalTo(cveId))
        .willReturn(serviceUnavailable()));

    vulnerabilityService.find(List.of(cveId), true)
        .subscribe()
        .withSubscriber(AssertSubscriber.create())
        .awaitCompletion().assertHasNotReceivedAnyItem();

    server.verify(1, getRequestedFor(urlPathTemplate(OSV_VULN_API_PATH)).withPathParam("id", equalTo(cveId)));

    server.stubFor(get(urlPathTemplate(OSV_VULN_API_PATH))
        .withPathParam("id", equalTo(cveId))
        .willReturn(ok().withBodyFile("osv-data/" + cveId + ".json").withHeader(WireMockExtensions.CONTENT_TYPE,
            MediaType.APPLICATION_JSON)));

    // Wait for the retry to make a successful request
    Thread.sleep(1500);

    server.verify(2, getRequestedFor(urlPathTemplate(OSV_VULN_API_PATH))
        .withPathParam("id", equalTo(cveId)));
    verify(repository).setAliases(List.of("GHSA-gwqq-6vq7-5j86", "PYSEC-2023-138"), cveId);
  }
}
