package com.redhat.ecosystemappeng.service.osv;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.cloud.storage.Blob;
import com.google.cloud.storage.Storage;
import com.google.cloud.storage.StorageException;
import com.google.cloud.storage.StorageOptions;
import com.redhat.ecosystemappeng.model.IngestRecord;
import com.redhat.ecosystemappeng.model.Vulnerability;
import com.redhat.ecosystemappeng.serialization.VulnerabilityDeserializer;
import com.redhat.ecosystemappeng.service.nvd.Enricher;

import jakarta.annotation.PostConstruct;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

@ApplicationScoped
public class VulnerabilityLoader {

    private static final Logger LOGGER = LoggerFactory.getLogger(VulnerabilityLoader.class);

    private static final String OSV_BUCKET = "osv-vulnerabilities";
    
    public static final Collection<String> PROVIDERS = Arrays.asList("Maven", "Go", "npm", "PyPI");

    @ConfigProperty(name = "migration.osv.pageSize", defaultValue = "100")
    Integer pageSize;

    @Inject
    VulnerabilityRepository vulnRepo;

    @Inject
    IngestionRepository ingRepo;

    @Inject
    VulnerabilityDeserializer deserializer;

    @Inject
    Enricher nvdEnricher;

    Storage storage;

    @PostConstruct
    public void init() {
        storage = StorageOptions.getUnauthenticatedInstance().getService();
    }

    public void load(String provider, boolean force) {
        var folder = provider + "/";
        try {
            LOGGER.info("Loading {}", folder);
            var record = force ? null : ingRepo.findLatest(folder);
            var options = defaultOptions(folder);
            if (record != null) {
                if (record.getFinished() != null) {
                    LOGGER.info("Skip sync for {}. Completed on {}", folder, record.getFinished());
                    return;
                }
                if (record.getLastPageToken() != null) {
                    options.add(Storage.BlobListOption.endOffset(record.getLastPageToken()));
                    LOGGER.info("Resuming sync for {}. Starting from {}", folder, record.getLastPageToken());
                }
            } else {
                record = new IngestRecord.Builder().folder(folder).build();
                ingRepo.persist(record);
                LOGGER.info("Starting sync for {}. No previous load found", folder, record.getLastPageToken());
            }
            var blobs = storage.list(OSV_BUCKET,
                    options.toArray(new Storage.BlobListOption[0]));

            while (blobs != null) {
                var values = blobs.streamValues().map(this::toVulnerability).filter(Objects::nonNull).collect(Collectors.toList());
                if(values.size() == 0) {
                    LOGGER.info("No elements found in page for {}", folder);
                    continue;
                }
                vulnRepo.persistOrUpdate(values);
                LOGGER.info("Loaded page of {} elements for {}", values.size(), folder);
                var lastProcessed = values.get(values.size() - 1);
                record.setProcessed(record.getProcessed() + values.size())
                        .setLastPageToken(String.format("%s%s.json", folder, lastProcessed.vulnId()));
                ingRepo.update(record);
                blobs = blobs.getNextPage();
            }
            LOGGER.info("Loaded {}", folder);
            record.setFinished(new Date(System.currentTimeMillis()));
            ingRepo.update(record);
        } catch (Exception e) {
            LOGGER.error("Unable to process folder {}", folder, e);
        }
    }

    public void load(boolean force) {
        PROVIDERS.stream().parallel().forEach(f -> {
            load(f, force);
        });
    }

    private Vulnerability toVulnerability(Blob blob) {
        try {
            var vuln = deserializer.parse(blob.getContent());
            nvdEnricher.enrich(vuln);
            return vuln;
        } catch (IOException | StorageException e) {
            LOGGER.warn("Unable to parse vulnerability: {}", blob.getName(), e);
            return null;
        }
    }

    private List<Storage.BlobListOption> defaultOptions(String folder) {
        List<Storage.BlobListOption> opts = new ArrayList<>();
        opts.add(Storage.BlobListOption.prefix(folder));
        opts.add(Storage.BlobListOption.currentDirectory());
        opts.add(Storage.BlobListOption.matchGlob("**.json"));
        opts.add(Storage.BlobListOption.pageSize(pageSize));
        return opts;
    }

}
