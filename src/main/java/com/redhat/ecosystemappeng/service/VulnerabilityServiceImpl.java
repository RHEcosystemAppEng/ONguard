package com.redhat.ecosystemappeng.service;

import java.io.IOException;
import java.util.Date;
import java.util.List;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;

import org.eclipse.microprofile.rest.client.inject.RestClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.NullNode;
import com.redhat.ecosystemappeng.model.Vulnerability;
import com.redhat.ecosystemappeng.service.nvd.NvdService;
import com.redhat.ecosystemappeng.service.osv.OsvApi;
import com.redhat.ecosystemappeng.service.osv.OsvLoader;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.ws.rs.WebApplicationException;
import jakarta.ws.rs.core.Response.Status;

@ApplicationScoped
public class VulnerabilityServiceImpl implements VulnerabilityService {

    private static final Logger LOGGER = LoggerFactory.getLogger(VulnerabilityServiceImpl.class);

    @Inject
    VulnerabilityRepository repository;

    @Inject
    OsvLoader osvLoader;

    @Inject
    NvdService nvdService;

    @Inject
    ObjectMapper mapper;

    @RestClient
    OsvApi osvApi;

    @Inject
    ExecutorService executorService;

    @Override
    public Vulnerability getByCveId(String cveId, boolean reload) {
        var vuln = repository.get(cveId);
        if (!reload && vuln.exists()) {
            return vuln;
        }
        return load(vuln);
    }

    @Override
    public List<Vulnerability> findByCveId(List<String> cveIds, boolean reload) {
        return repository.list(cveIds).stream().map(vuln -> {
            if (!reload && vuln.exists()) {
                return vuln;
            }
            return load(vuln);
        }).toList();
    }

    @Override
    public Vulnerability getByVulnId(String vulnId, boolean reload) {
        var vuln = repository.getByVulnId(vulnId);
        if (!reload && vuln.exists()) {
            return vuln;
        }
        return load(vuln);
    }

    @Override
    public List<Vulnerability> findByVulnId(List<String> cveIds, boolean reload) {
        return repository.listByVulnIds(cveIds).stream().map(vuln -> {
            if (!reload && vuln.exists()) {
                return vuln;
            }
            return load(vuln);
        }).toList();
    }

    private Vulnerability load(Vulnerability vuln) {
        var builder = new Vulnerability.Builder().vulnId(vuln.vulnId()).cveId(vuln.cveId());
        if (vuln.created() == null) {
            builder.created(new Date());
        } else {
            builder.created(vuln.created()).lastModified(new Date());
        }
        if (vuln.vulnId() != null) {
            var alias = osvLoader.getCveAlias(vuln.vulnId());
            if (alias != null) {
                builder.cveId(alias.cveId());
                var existing = repository.get(alias.cveId());
                // missing match between cve and vulnId
                if (existing.exists() && !NullNode.getInstance().equals(existing.nvdData())) {
                    builder.nvdData(existing.nvdData()).created(existing.created()).lastModified(new Date());
                    var updated = builder.build();
                    repository.save(updated);
                    return updated;
                }
            }
        }
        if (builder.getCveId() != null) {
            var data = nvdService.findByCve(builder.getCveId());
            if (data != null) {
                try {
                    var json = mapper.readTree(data);
                    builder.nvdData(json);
                    if (builder.getVulnId() == null) {
                        addAliases(vuln);
                    }
                } catch (IOException e) {
                    LOGGER.error("Unable to parse NVD data for {}", vuln.cveId(), e);
                }
            }
        }
        if (builder.getCveId() == null) {
            builder.cveId("missing_cve::" + builder.getVulnId());
        }
        var newVuln = builder.build();
        repository.save(newVuln);
        return newVuln;
    }

    private void addAliases(Vulnerability vuln) {
        executorService.execute(() -> {
            try {
                var response = osvApi.getVuln(vuln.cveId());
                if (response == null || response.aliases() == null) {
                    return;
                }
                var first = response.aliases().stream().filter(a -> a.startsWith("GHSA-")).findFirst();
                if (first.isPresent()) {
                    var updated = new Vulnerability.Builder(vuln).vulnId(first.get()).lastModified(new Date()).build();
                    repository.save(updated);
                }
            } catch (WebApplicationException e) {
                if (e.getResponse().getStatus() == Status.NOT_FOUND.getStatusCode()) {
                    LOGGER.info("Not found alias for {} in OSV", vuln.cveId());
                } else {
                    LOGGER.warn("Unable to retrieve OSV data for {}", vuln.cveId(), e);
                }
            }

        });
    }

}
