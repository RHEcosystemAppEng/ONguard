package com.redhat.ecosystemappeng.service;

import java.io.IOException;
import java.util.Date;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.redhat.ecosystemappeng.model.Vulnerability;
import com.redhat.ecosystemappeng.service.nvd.NvdService;
import com.redhat.ecosystemappeng.service.osv.OsvLoader;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

@ApplicationScoped
public class VulnerabilityServiceImpl implements VulnerabilityService {

    private static final Logger LOGGER = LoggerFactory.getLogger(VulnerabilityServiceImpl.class);

    @Inject
    VulnerabilityRepository repository;

    @Inject
    OsvLoader osvLoader;

    @Inject
    NvdService nvdService;

    @Inject
    ObjectMapper mapper;

    @Override
    public Vulnerability getByCveId(String cveId, boolean reload) {
        var vuln = repository.get(cveId);
        if (!reload && vuln.exists()) {
            return vuln;
        }
        if (vuln == null) {
            vuln = new Vulnerability.Builder().cveId(cveId).build();
        }
        return load(vuln);
    }

    @Override
    public List<Vulnerability> findByCveId(List<String> cveIds, boolean reload) {
        return repository.list(cveIds).stream().map(vuln -> {
            if (!reload && vuln.exists()) {
                return vuln;
            }
            return load(vuln);
        }).toList();
    }

    @Override
    public Vulnerability getByVulnId(String vulnId, boolean reload) {
        var vuln = repository.getByVulnId(vulnId);
        if(!reload && vuln.exists()) {
            return vuln;
        }
        if(vuln == null) {
            vuln = new Vulnerability.Builder().vulnId(vulnId).build();
        }
        return load(vuln);
    }

    @Override
    public List<Vulnerability> findByVulnId(List<String> cveIds, boolean reload) {
        return repository.listByVulnIds(cveIds).stream().map(vuln -> {
            if (!reload && vuln.exists()) {
                return vuln;
            }
            return load(vuln);
        }).toList();
    }

    private Vulnerability load(Vulnerability vuln) {
        var builder = new Vulnerability.Builder().vulnId(vuln.vulnId()).cveId(vuln.cveId());
        if (vuln.created() == null) {
            builder.created(new Date());
        } else {
            builder.created(vuln.created()).lastModified(new Date());
        }
        if (vuln.vulnId() != null) {
            var alias = osvLoader.getCveAlias(vuln.vulnId());
            if (alias != null) {
                builder.cveId(alias.cveId());
                var existing = repository.get(alias.cveId());
                // missing match between cve and vulnId
                if(existing.exists()) {
                    builder.nvdData(existing.nvdData()).created(existing.created()).lastModified(new Date());
                    var updated = builder.build();
                    repository.save(updated);
                    return updated;
                }
            }
        }
        if (builder.getCveId() != null) {
            var data = nvdService.findByCve(builder.getCveId());
            if (data != null) {
                try {
                    var json = mapper.readTree(data);
                    builder.nvdData(json);
                } catch (IOException e) {
                    LOGGER.error("Unable to parse NVD data for {}", vuln.vulnId(), e);
                }
            }
        }
        if(builder.getCveId() == null) {
            builder.cveId("missing_cve::" + builder.getVulnId());
        }
        var newVuln = builder.build();
        repository.save(newVuln);
        return newVuln;
    }

}
