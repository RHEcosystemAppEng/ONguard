package com.redhat.ecosystemappeng.service;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ExecutorService;

import org.eclipse.microprofile.rest.client.inject.RestClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.NullNode;
import com.redhat.ecosystemappeng.model.Vulnerability;
import com.redhat.ecosystemappeng.service.nvd.NvdService;
import com.redhat.ecosystemappeng.service.osv.OsvApi;
import com.redhat.ecosystemappeng.service.osv.OsvLoader;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.ws.rs.WebApplicationException;
import jakarta.ws.rs.core.Response.Status;

@ApplicationScoped
public class VulnerabilityServiceImpl implements VulnerabilityService {

    private static final Logger LOGGER = LoggerFactory.getLogger(VulnerabilityServiceImpl.class);

    @Inject
    VulnerabilityRepository repository;

    @Inject
    OsvLoader osvLoader;

    @Inject
    NvdService nvdService;

    @Inject
    ObjectMapper mapper;

    @RestClient
    OsvApi osvApi;

    @Inject
    ExecutorService executorService;

    @Override
    public Vulnerability getByCveId(String cveId, boolean reload) {
        var vuln = repository.get(cveId);
        return load(vuln, reload);
    }

    @Override
    public List<Vulnerability> findByCveId(List<String> cveIds, boolean reload) {
        return repository.list(cveIds)
                .stream()
                .map(vuln -> load(vuln, reload))
                .toList();
    }

    @Override
    public Vulnerability getByAlias(String aliasId, boolean reload) {
        var vuln = repository.getByAlias(aliasId);
        return load(vuln, reload);
    }

    @Override
    public List<Vulnerability> findByAlias(List<String> aliases, boolean reload) {
        return repository.listByAliases(aliases)
                .stream()
                .map(vuln -> load(vuln, reload))
                .toList();
    }

    private Vulnerability load(Vulnerability vuln, boolean reload) {
        if (!reload && vuln.exists()) {
            return vuln;
        }
        return load(vuln);
    }

    private Vulnerability load(Vulnerability vuln) {
        var builder = new Vulnerability.Builder().aliases(vuln.aliases()).cveId(vuln.cveId());
        if (vuln.created() == null) {
            builder.created(new Date());
        } else {
            builder.created(vuln.created()).lastModified(new Date());
        }
        if (vuln.aliases() != null && !vuln.aliases().isEmpty()) {
            var alias = osvLoader.getCveByAlias(vuln.aliases().get(0));
            if (alias != null) {
                Set<String> aliases = new HashSet<>(alias.aliases());
                aliases.addAll(vuln.aliases());
                builder.cveId(alias.cveId()).aliases(new ArrayList<>(aliases));
                var existing = repository.get(alias.cveId());
                // missing match between cve and vulnId
                if (existing.exists() && !NullNode.getInstance().equals(existing.nvdData())) {
                    builder.nvdData(existing.nvdData()).created(existing.created()).lastModified(new Date());
                    var updated = builder.build();
                    repository.save(updated);
                    return updated;
                }
            }
        }
        if (builder.getCveId() != null) {
            var data = nvdService.findByCve(builder.getCveId());
            if (data != null) {
                try {
                    var json = mapper.readTree(data);
                    builder.nvdData(json);
                    if (builder.getAliases() == null || builder.getAliases().isEmpty()) {
                        populateAliases(vuln);
                    }
                } catch (IOException e) {
                    LOGGER.error("Unable to parse NVD data for {}", vuln.cveId(), e);
                }
            }
        }
        if (builder.getCveId() == null) {
            builder.cveId("missing_cve::" + builder.getAliases().toString());
        }
        var newVuln = builder.build();
        repository.save(newVuln);
        return newVuln;
    }

    private void populateAliases(Vulnerability vuln) {
        executorService.execute(() -> {
            try {
                var response = osvApi.getVuln(vuln.cveId());
                if (response == null || response.aliases() == null) {
                    return;
                }
                if (!response.aliases().isEmpty()) {
                    var updated = new Vulnerability.Builder(vuln).aliases(response.aliases()).lastModified(new Date()).build();
                    repository.save(updated);
                }
            } catch (WebApplicationException e) {
                if (e.getResponse().getStatus() == Status.NOT_FOUND.getStatusCode()) {
                    LOGGER.info("Not found alias for {} in OSV", vuln.cveId());
                } else {
                    LOGGER.warn("Unable to retrieve OSV data for {}", vuln.cveId(), e);
                }
            }

        });
    }

}
