/*
 * Copyright 2024 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.redhat.ecosystemappeng.onguard.repository.redis;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

import org.jboss.logging.Logger;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.redhat.ecosystemappeng.onguard.model.Alias;
import com.redhat.ecosystemappeng.onguard.model.Vulnerability;
import com.redhat.ecosystemappeng.onguard.model.VulnerabilityAlias;
import com.redhat.ecosystemappeng.onguard.repository.VulnerabilityRepository;

import io.quarkus.redis.datasource.ReactiveRedisDataSource;
import io.quarkus.redis.datasource.json.ReactiveJsonCommands;
import io.quarkus.redis.datasource.value.ReactiveValueCommands;
import io.smallrye.mutiny.Uni;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

@ApplicationScoped
public class VulnerabilityRedisRepository implements VulnerabilityRepository {

  private static final Logger LOGGER = Logger.getLogger(VulnerabilityRedisRepository.class);

  @Inject
  ObjectMapper mapper;

  private final ReactiveValueCommands<String, Alias> aliasCommands;
  private final ReactiveJsonCommands<String> vulnCommands;

  public VulnerabilityRedisRepository(ReactiveRedisDataSource ds) {
    this.vulnCommands = ds.json(String.class);
    this.aliasCommands = ds.value(Alias.class);
  }

  @Override
  public Uni<Vulnerability> get(String cveId) {
    if (cveId == null) {
      return Uni.createFrom().nullItem();
    }
    return vulnCommands.jsonGet(cvesKey(cveId), Vulnerability.class).onItem().ifNull()
        .continueWith(Vulnerability.builder().cveId(cveId).build());
  }

  private String cvesKey(String cveId) {
    return "cves:" + cveId;
  }

  @Override
  public Uni<Void> save(Vulnerability vulnerability) {
    return vulnCommands.jsonSet(cvesKey(vulnerability.cveId()), "$", vulnerability).chain(() -> {
      var alias = new Alias(vulnerability.cveId(), vulnerability.cveId());
      return aliasCommands.set(Alias.getKey(alias.id()), alias);
    });
  }

  public Uni<Void> setAliases(List<String> aliases, String cveId) {
    if (aliases != null && !aliases.isEmpty() && cveId != null) {
      return aliasCommands
          .mset(aliases.stream().collect(Collectors.toMap(v -> Alias.getKey(v), v -> new Alias(v, cveId))));
    }
    return Uni.createFrom().voidItem();
  }

  private Uni<List<Vulnerability>> list(List<String> cves) {
    // Arguments do not match the signature...
    if (cves == null || cves.isEmpty()) {
      return Uni.createFrom().item(Collections.emptyList());
    }
    var first = cvesKey(cves.get(0));
    var varargs = new ArrayList<>(cves.subList(1, cves.size()).stream().map(this::cvesKey).toList());
    varargs.add("$");
    return vulnCommands.jsonMget(first, varargs.toArray(new String[0])).onItem().transform(found -> {
      var results = new ArrayList<Vulnerability>();
      for (int i = 0; i < cves.size(); i++) {
        Vulnerability vuln = null;
        if (found.get(i) != null) {
          try {
            vuln = mapper.readValue(found.get(i).getJsonObject(0).encode(), Vulnerability.class);
          } catch (JsonProcessingException e) {
            LOGGER.warnf("Unable to parse vulnerability with id %s", cves.get(i), e);
          }
        }
        if (vuln == null) {
          vuln = Vulnerability.builder().cveId(cves.get(i)).build();
        }
        results.add(vuln);
      }
      return results;
    });

  }

  @Override
  public Uni<VulnerabilityAlias> getByAlias(String aliasId) {
    return aliasCommands.get(Alias.getKey(aliasId))
        .onItem().ifNull().continueWith(new Alias(aliasId, null))
        .chain(alias -> get(alias.cveId()))
        .onItem().transform(vuln -> new VulnerabilityAlias(aliasId, vuln))
        .onItem().ifNull().continueWith(new VulnerabilityAlias(aliasId, null));
  }

  @Override
  public Uni<List<VulnerabilityAlias>> listByAliases(List<String> aliasIds) {
    return aliasCommands.mget(aliasIds.stream().map(Alias::getKey).toList().toArray(new String[0]))
        .chain(aliases -> transformAliasToVulnerabilities(aliases, aliasIds));
  }

  private Uni<List<VulnerabilityAlias>> transformAliasToVulnerabilities(Map<String, Alias> aliases,
      List<String> aliasIds) {
    return list(aliases.values().stream().filter(Objects::nonNull).map(Alias::cveId).toList())
        .onItem()
        .transform(vulns -> vulns.stream()
            .distinct()
            .collect(Collectors.toMap(Vulnerability::cveId, v -> v)))
        .onItem()
        .transform(vulns -> {
          var cveIdCount = new HashSet<>();
          var results = new ArrayList<VulnerabilityAlias>();

          aliasIds.stream().forEach(aliasId -> {
            var alias = aliases.get(Alias.getKey(aliasId));
            if (alias == null || alias.cveId() == null) {
              results.add(new VulnerabilityAlias(aliasId, null));
            } else if (!cveIdCount.contains(alias.cveId())) {
              cveIdCount.add(alias.cveId());
              results.add(new VulnerabilityAlias(aliasId, vulns.get(alias.cveId())));
            }
          });
          return results;
        });
  }

  @Override
  public Uni<Void> removeAll() {
    return Uni.createFrom().voidItem().onItem().invoke(() -> aliasCommands.getDataSource().flushall());
  }

}
