/*
 * Copyright 2024 Red Hat, Inc. and/or its affiliates
 * and other contributors as indicated by the @author tags.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.redhat.ecosystemappeng.exhort.cve.service;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CompletionException;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.redhat.ecosystemappeng.exhort.cve.model.Vulnerability;

import io.quarkus.redis.datasource.RedisDataSource;
import io.quarkus.redis.datasource.json.JsonCommands;
import io.quarkus.redis.datasource.search.CreateArgs;
import io.quarkus.redis.datasource.search.FieldType;
import io.quarkus.redis.datasource.search.QueryArgs;
import io.quarkus.redis.datasource.search.SearchCommands;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

@ApplicationScoped
public class VulnerabilityRepository {

    private static final String VULNID_INDEX = "idx:aliases";

    private static final Logger LOGGER = LoggerFactory.getLogger(VulnerabilityRepository.class);

    @Inject
    ObjectMapper mapper;

    private final JsonCommands<String> jsonCommands;
    private final SearchCommands<String> searchCommands;

    public VulnerabilityRepository(RedisDataSource ds) {
        this.jsonCommands = ds.json(String.class);
        this.searchCommands = ds.search();
        try {
            // Requires creating an index
            // FT.CREATE idx:aliases ON JSON SCHEMA $.aliases as aliases TAG
            if (this.searchCommands.ft_list().stream().noneMatch(s -> s.equals(VULNID_INDEX))) {
                this.searchCommands.ftCreate(VULNID_INDEX,
                        new CreateArgs()
                                .indexedField("$.aliases", "aliases", FieldType.TAG)
                                .onJson());
            }
        } catch (CompletionException e) {
            LOGGER.warn("Trying to create existing index {}", VULNID_INDEX, e);
        }
    }

    public Vulnerability get(String cveId) {
        var vuln = jsonCommands.jsonGet(cveId, Vulnerability.class);
        if (vuln == null) {
            return new Vulnerability.Builder().cveId(cveId).build();
        }
        return vuln;
    }

    public void save(Vulnerability vulnerability) {
        jsonCommands.jsonSet(vulnerability.cveId(), vulnerability);
    }

    public List<Vulnerability> list(List<String> cves) {
        // Arguments do not match the signature...
        if (cves == null || cves.isEmpty()) {
            return Collections.emptyList();
        }
        var first = cves.get(0);
        var varargs = new ArrayList<>(cves.subList(1, cves.size()));
        varargs.add("$");
        var found = jsonCommands.jsonMget(first, varargs.toArray(new String[0]));
        var results = new ArrayList<Vulnerability>();
        for (int i = 0; i < cves.size(); i++) {
            Vulnerability vuln = null;
            if (found.get(i) != null) {
                try {
                    vuln = mapper.readValue(found.get(i).getJsonObject(0).encode(), Vulnerability.class);
                } catch (JsonProcessingException e) {
                    LOGGER.warn("Unable to parse vulnerability with id {}", cves.get(i), e);
                }
            }
            if (vuln == null) {
                vuln = new Vulnerability.Builder().cveId(cves.get(i)).build();
            }
            results.add(vuln);
        }
        return results;
    }

    public Vulnerability getByAlias(String alias) {
        var response = searchCommands.ftSearch(VULNID_INDEX, "@aliases:{" + alias.replaceAll("\\-", "\\\\-") + "}",
                new QueryArgs().limit(0, 1).withPayloads());
        if (response != null && !response.documents().isEmpty()) {
            try {
                return mapper.readValue(response.documents().get(0).property("$").asBytes(), Vulnerability.class);
            } catch (IOException e) {
                LOGGER.error("Unable to deserialize Vulnerability {}", alias, e);
            }
        }
        return new Vulnerability.Builder().aliases(List.of(alias)).build();
    }

    public List<Vulnerability> listByAliases(List<String> aliases) {
        var response = searchCommands.ftSearch(VULNID_INDEX,
                "@aliases:{" + String.join("|", aliases.toArray(new String[0])).replaceAll("\\-", "\\\\-") + "}",
                new QueryArgs().verbatim().withPayloads());
        if (response == null || response.documents().isEmpty()) {
            return aliases.stream().map(alias -> new Vulnerability.Builder().aliases(List.of(alias)).build()).toList();
        }
        var found = response.documents().stream().map(v -> {
            try {
                var val = mapper.readValue(v.property("$").asBytes(), Vulnerability.class);
                return val;
            } catch (IOException e) {
                String alias = v.property("aliases").asString();
                LOGGER.error("Unable to deserialize Vulnerability {}", alias, e);
                return new Vulnerability.Builder().aliases(List.of(alias)).build();
            }
        }).collect(Collectors.toMap(val -> {
            var alias = aliases.stream().filter(a -> val.aliases().contains(a)).findFirst();
            if (alias.isPresent()) {
                return alias.get();
            }
            throw new IllegalStateException("Unexpected item received: " + val.aliases());
        }, val -> val));
        
        return aliases.stream().map(alias -> {
            Vulnerability vuln = found.get(alias);
            if (vuln == null) {
                return new Vulnerability.Builder().aliases(List.of(alias)).build();
            }
            return vuln;
        }).toList();
    }

}
